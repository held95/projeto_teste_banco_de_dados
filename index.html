<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Consulta de Registros</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #dff5e0;
    color: #333;
  }
  h1 {
    text-align: center;
    color: #2e7d32;
  }
  label {
    font-weight: bold;
  }
  input, select, button {
    padding: 8px;
    margin: 5px;
    border-radius: 5px;
    border: 1px solid #aaa;
  }
  button {
    background-color: #2e7d32;
    color: white;
    cursor: pointer;
  }
  button:hover {
    background-color: #1b5e20;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    margin-top: 20px;
    border-radius: 10px;
    overflow: hidden;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 8px;
    text-align: left;
  }
  th {
    background-color: #a5d6a7;
  }
  tr:hover {
    background-color: #c8e6c9;
  }
  #nameError {
    color: red;
    font-weight: bold;
  }
</style>
<!-- Bibliotecas para Excel e PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>

<h1>ðŸ”Ž Consulta de Registros</h1>

<!-- Filtros -->
<label>Nome:</label>
<input type="text" id="filterName" placeholder="Digite o nome">

<label>CPF:</label>
<input type="text" id="filterCpf" placeholder="Digite o CPF">

<label>Planilha:</label>
<select id="filterSheet"></select>

<button onclick="applyFilter()">Pesquisar</button>
<button onclick="exportToExcel()">Gerar Excel</button>
<button onclick="exportToPDF()">Gerar PDF</button>

<p id="nameError"></p>

<!-- Tabela de resultados -->
<div id="results"></div>

<script>
// VariÃ¡veis globais
let jsonData = {};
let validNames = [];
let currentFilteredData = [];

// Carregar JSON
fetch("resultado_final.json")
  .then(res => res.json())
  .then(data => {
    jsonData = data;
    const sheetSelect = document.getElementById("filterSheet");
    Object.keys(data).forEach(sheet => {
      const option = document.createElement("option");
      option.value = sheet;
      option.text = sheet;
      sheetSelect.appendChild(option);
    });

    // Popular lista de nomes vÃ¡lidos a partir do JSON
    validNames = [];
    Object.values(data).forEach(sheet => {
      sheet.forEach(row => {
        if(row.Nome) validNames.push(row.Nome);
      });
    });
    validNames = [...new Set(validNames)]; // remover duplicados
  });

// Normalizar strings
function normalizeText(text) {
  return text ? text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim() : "";
}

// Encontrar nomes similares
function findSimilarNames(input) {
  const normalizedInput = normalizeText(input);
  return validNames.filter(name => normalizeText(name).includes(normalizedInput));
}

// Aplicar filtros e gerar tabela
function applyFilter() {
  const sheetName = document.getElementById("filterSheet").value;
  const nameFilter = normalizeText(document.getElementById("filterName").value);
  const cpfFilter = document.getElementById("filterCpf").value.trim();
  const nameError = document.getElementById("nameError");
  nameError.textContent = "";

  if(nameFilter && !validNames.some(name => normalizeText(name) === nameFilter)) {
    const suggestions = findSimilarNames(nameFilter);
    nameError.textContent = "Nome incorreto ou nÃ£o cadastrado." +
      (suggestions.length > 0 ? " SugestÃµes: " + suggestions.join(", ") : "");
  }

  const sheetData = jsonData[sheetName] || [];
  const filtered = sheetData.filter(row => {
    const rowText = normalizeText(Object.values(row).join(" "));
    const matchName = nameFilter ? rowText.includes(nameFilter) : true;
    const matchCpf = cpfFilter ? Object.values(row).join(" ").includes(cpfFilter) : true;
    return matchName && matchCpf;
  });

  currentFilteredData = filtered; // guardar para exportaÃ§Ã£o

  const resultsDiv = document.getElementById("results");
  if(filtered.length === 0) {
    resultsDiv.innerHTML = "<p>Nenhum resultado encontrado.</p>";
    return;
  }

  let table = "<table><thead><tr>";
  Object.keys(filtered[0]).forEach(col => table += `<th>${col}</th>`);
  table += "</tr></thead><tbody>";
  filtered.forEach((row, rowIndex) => {
    table += "<tr>";
    Object.entries(row).forEach(([key, val], colIndex) => {
      table += `<td contenteditable="true" onblur="updateCell('${sheetName}', ${rowIndex}, '${key}', this.textContent)">${val}</td>`;
    });
    table += "</tr>";
  });
  table += "</tbody></table>";
  resultsDiv.innerHTML = table;
}

// Atualizar valor editado na tabela
function updateCell(sheetName, rowIndex, key, newValue) {
  jsonData[sheetName][rowIndex][key] = newValue;

  if(key === "Nome") {
    validNames = [];
    Object.values(jsonData).forEach(sheet => {
      sheet.forEach(row => {
        if(row.Nome) validNames.push(row.Nome);
      });
    });
    validNames = [...new Set(validNames)];
  }
}

// Exportar Excel
function exportToExcel() {
  if(currentFilteredData.length === 0) {
    alert("Nenhum dado para exportar.");
    return;
  }
  const worksheet = XLSX.utils.json_to_sheet(currentFilteredData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Resultados");
  XLSX.writeFile(workbook, "consulta_registros.xlsx");
}

// Exportar PDF
function exportToPDF() {
  if(currentFilteredData.length === 0) {
    alert("Nenhum dado para exportar.");
    return;
  }
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  const columns = Object.keys(currentFilteredData[0]);
  const rows = currentFilteredData.map(row => columns.map(col => row[col]));
  doc.autoTable({
    head: [columns],
    body: rows,
  });
  doc.save("consulta_registros.pdf");
}
</script>

<!-- jsPDF AutoTable -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

</body>
</html>
